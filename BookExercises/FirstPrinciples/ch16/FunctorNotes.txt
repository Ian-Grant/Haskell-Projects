Functor

Chapter Summary
  - Return of the Higher-Kinded Types
  - Fmaps galore, and on diffrent data types than just lists.
  - Typeclasses and Constructor Classes

Last Chapter on monoid which was about algebra and turning it into a typeclass.
This Chapter and the following Applicative and Monad are similar but each
    algebra is more powerful than the last. (This isn't even my final form.)

General Concept is same, abstract a common pattern make it follow certain laws.
    Give cool name and live in wonder with it.

This chapter is about Functor which is all about a pattern of mapping over a structure
    aka fmap back in List Chapter

Functors are combinators, they take a sentence or phrase as input and
                    outputs a sentence or phrase with a logic operation applied onto it

    Ex: Negation is a functor in this sense because when negation is applied to
        a sentance, A, it produces the negated version, ~A, as output.
        It lifts the concept of negation over the entire sentence or phrase
        structure without changing the internal structure.

===What is a Functor?===

A functor is a way to apply a function over a structure that we don't want to alter.
    A function is applied to value inside structure and leave structure alone.
    No elements are removed or added. Only transformed.

===FMAP===

--Map&Fmap--
map (\x -> x > 3) [1..6]
[False,False,False,True,True,True]

fmap (\x -> x > 3) [1..6]
[False,False,False,True,True,True]

map and fmap work the same as eachother when applied on a List.

Tho fmap can be applied to alot more data types while map only works on lists.

map exists solely for new people to haskell so they only see errors about lists
    when using map versus seeing errors about Functors when using fmap.

the function f in the Functor definition must be kind * -> *
    For a Few Reasons
        1. Each argument and result in the type signature for a function
            must be a fully applied type. Each arg must be kind *.
        2. The type f was applied to a single argument in two diffrent places
            f a and f b. Since f a and f b must have kind *. f by itself is * -> *
Every arg to (->) must be of kind *
    because the kind of (->) is * -> *
Each arg and result of every function must be a type constant not a type constructor
    aka kind *

===Functor is function application===
Inflix operator for fmap is <$>.

Functor is a typeclass for function application over or through some data structure f.
    and we want to leave structure f alone and untouched but modify the data
    inside but have the structure be unchanged.

===FUNCTOR LAWS===

Idenitiy
fmap id == id
fmap id "Hi Julie"
"Hi Julie"

===Composition===

fmap (f . g) == fmap f . fmap g

composing the function inside fmap will be the same
as running both functions in fmap seperately then composing them.

===Structure Preservation===

Both of the above laws touch upon rule of structural preservation.


===The Good the Bad the Ugly===

